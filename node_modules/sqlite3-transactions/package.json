{
  "name": "sqlite3-transactions",
  "version": "0.0.3",
  "description": "Adds transactions support to node-sqlite3.",
  "main": "sqlite3-transactions.js",
  "scripts": {
    "test": "node test"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/Strix-CZ/sqlite3-transactions.git"
  },
  "keywords": [
    "sqlite",
    "sqlite3",
    "node-sqlite3",
    "transaction",
    "transactions",
    "node.js"
  ],
  "author": {
    "name": "Jan Å imonek",
    "email": "jan.simonek@gmail.com"
  },
  "license": "BSD-2-Clause",
  "bugs": {
    "url": "https://github.com/Strix-CZ/sqlite3-transactions/issues"
  },
  "dependencies": {
    "underscore": ">= 1.5.2"
  },
  "devDependencies": {
    "slide": ">= 1.1.5",
    "sqlite3": ">= 2.1"
  },
  "readme": "#sqlite3-transactions\r\n\r\nAdds transactions support to [node-sqlite3](https://github.com/developmentseed/node-sqlite3).\r\n\r\n## Background\r\n\r\nNode-sqlite3 is a great way how to access a SQLite database but id doesn't provide support for transactions yet. The underlying SQLite database can handle transactions easily so you can still do:\r\n```javascript\r\ndb.serialize(function() {\r\n    db.exec(\"BEGIN\");\r\n    ...\r\n    db.exec(\"COMMIT\");\r\n});\r\n```\r\n\r\nThis works fine until you add an async operation between `BEGIN` and `COMMIT`. The problem is that node-sqlite3 uses single connection to the database and thus queries from other places can end up intermixing with each other messing up the transactions.\r\n\r\nSqlite3-transactions solves this problem by transparently locking the database while in a transaction. If database is locked all queries which don't belong to the transaction are queued and executed after the transaction is finished. As a bonus you got a clean nice API for transactions.\r\n\r\n## Install\r\n```\r\nnpm install sqlite3\r\nnpm install sqlite3-transactions\r\n```\r\n\r\n## Usage\r\n```javascript\r\nvar sqlite3 = require(\"sqlite3\"),\r\n\tTransactionDatabase = require(\"sqlite3-transactions\").TransactionDatabase;\r\n\r\n// Wrap sqlite3 database\r\nvar db = new TransactionDatabase(\r\n\tnew sqlite3.Database(\"test.sqlite\", sqlite3.OPEN_READWRITE | sqlite3.OPEN_CREATE)\r\n);\r\n\r\n// Use db as normal sqlite3.Database object.\r\ndb.exec(\"CREATE TABLE ...\", function(err) {\r\n\t// table created\r\n});\r\n\r\n// Begin a transaction.\r\ndb.beginTransaction(function(err, transaction) {\r\n\t// Now we are inside a transaction.\r\n\t// Use transaction as normal sqlite3.Database object.\r\n\ttransaction.run(\"INSERT ...\");\r\n\r\n\r\n\t// All calls db.exec(), db.run(), db.beginTransaction(), ... are\r\n\t// queued and executed after you do transaction.commit() or transaction.rollback()\r\n\t\r\n\t// This will be executed after the transaction is finished.\r\n\tdatabase.run(\"INSERT ...\"); \r\n    \r\n    // Feel free to do any async operations.\r\n    someAsync(function() {\r\n    \r\n        // Remember to .commit() or .rollback()\r\n\t    transaction.commit(function(err) {\r\n            if (err) return console.log(\"Sad panda :-( commit() failed.\", err);\r\n            console.log(\"Happy panda :-) commit() was successful.\");\r\n        );\r\n\t    // or transaction.rollback()\r\n        \r\n    });\r\n});\r\n```\r\n\r\nI haven't mentioned one feature in the example - on `error` event automatic `rollback()` is performed on the current transaction.\r\n\r\n## API\r\n### database.beginTransaction(callback)\r\nCall this method to start a transaction. The database is locked and all queries are queued until the transaction is over. `callback` receives two parameters `error` and `transaction`. Use `transaction` to perform operations directly with database. You must call `transaction.commit()` or `transaction.rollback()` to finish the transaction and unlock the database. You don't have to `rollback()` in the case:\r\n\r\n * there is and `error` passed to the callback.\r\n * there was an `error` event during the transaction.\r\n\r\n### transaction.commit(callback)\r\nCommits the transaction. The `callback(error)` is called after the transaction is committed. If `error` is set then the commit failed for some reason and rollback was performed instead.\r\n\r\nQueued operations are executed after the actual commit but before the `callback`. This helps to prevent starvation.\r\n\r\n### transaction.rollback(callback)\r\nRolls back the transaction. The `callback(error)`is called after the operation is completed.\r\n\r\n\r\n## Important notes\r\nRemember to call `commit()` or `rollback()` on each transaction otherwise you lock your DB forever.\r\n\r\nsqlite3-transactions is in very early stage of development. Please help me test it. ",
  "readmeFilename": "README.md",
  "_id": "sqlite3-transactions@0.0.3",
  "dist": {
    "shasum": "b43d5f456a70cd9a3f5b38c6a750a918423d9696"
  },
  "_from": "sqlite3-transactions@",
  "_resolved": "https://registry.npmjs.org/sqlite3-transactions/-/sqlite3-transactions-0.0.3.tgz"
}
